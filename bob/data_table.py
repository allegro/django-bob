#!/usr/bin/env python
# -*- coding: utf-8 -*-

import cStringIO as StringIO

from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.http import HttpResponse

from bob import csvutil


class DataTableColumn(object):
    """
    A container object for all the information about a columns header

    :param choice - set if field is dj.choices object
    :param header_name - name to display in columns header
    :param field - field name in model
    :param type - icon type generated by bob header_table tag
    :param selectable - header in bob tag is selectable
    :param bob_tag - set if the column is to be generated by bob tag
    """
    def __init__(self, header_name, **kwargs):
        self.choice = kwargs.get('choice')        
        self.header_name = header_name
        self.field = kwargs.get('field')
        self.type = kwargs.get('type',)
        self.selectable = kwargs.get('selectable')
        self.bob_tag = kwargs.get('bob_tag')


class DataTableMixin(object):
    """Add this Mixin to your django view to handle page pagination.

    In your controller:
    1. Inherit from this mixin
    2. Define ROW_PER_SIZE attribute
    3. Define FILE_NAME attribute
    4. Define columns attribute contains list of
    bob.data_table.DataTableColumn objects
    5. In get() function call self.paginate_query(your_query, columns).

    Result is stored in the self.page_contents.
    Data for template can be obtained from
    self.get_context_data_paginator() dict to the template.

    In your template add code:
    {% pagination page url_query=url_query show_all=0 show_csv=0 fugue_icons=1 %}
    and
    {% table_header columns url_query sort %}

    All done!

    """

    def get_csv_header(self):
        return [col.header_name for col in self.columns if col.export]

    def get_choice_name(self, obj, field):
        if obj:
            try:
                return getattr(obj, 'get_' + field + '_display')()
            except AttributeError:
                pass
        return ''

    def get_cell(self, obj, field, choice):
        if choice:
            cell = self.get_choice_name(obj, field)
        else:
            try:
                cell = getattr(obj, field)
            except AttributeError:
                cell = ''
        return cell

    def get_export_response(self, **kwargs):
        return self.page_contents

    def get_context_data_paginator(self, **kwargs):
        """Returns paginator data dict, crafted for usage in template."""
        return {
            'page': self.page_contents,
            'pages': self.get_pages(self.paginator, self.page_number),
        }


    def paginate_query(self, queryset):
        """Paginate given query."""
        queryset = self.sort_queryset(queryset, columns=self.columns)
        if self.export_requested():
            self.page_contents = self.handle_csv_export(queryset)
            return self.page_contents
        else:
            self.paginate(queryset)
            return self.page_contents

    def sort_queryset(self, queryset, columns, sort=None):
        if columns:
            if sort is None:
                sort = self.request.GET.get('sort')
            if sort:
                sort_columns = None
                for column in columns:
                    if column.sort_expression and (column.field ==
                                                   sort.strip('-')):
                        sort_columns = column.sort_expression
                        break
                if sort_columns:
                    if sort.startswith('-'):
                        sort_columns = '-' + sort_columns
                    if queryset and sort:
                        queryset = queryset.order_by(sort_columns)
        self.sort = sort
        return queryset

    def paginate(self, queryset):
        """Internal pagination function"""
        page = self.request.GET.get('page') or 1
        self.page_number = int(page)
        self.paginator = Paginator(queryset, self.ROWS_PER_PAGE)
        try:
            self.page_contents = self.paginator.page(page)
        except PageNotAnInteger:
            self.page_contents = self.paginator.page(1)
            page = 1
        except EmptyPage:
            self.page_contents = self.paginator.page(self.paginator.num_pages)
            page = self.paginator.num_pages
        return page

    def export_requested(self, *args, **kwargs):
        """Returns True if csv export was requested by the user or
        False in other case"""
        export = self.request.GET.get('export')
        return export == 'csv'

    def handle_csv_export(self, queryset):
        """Returns HTTPResponse with cvs stream data"""
        return self.do_csv_export(queryset)

    def get_csv_data(self, queryset):
        """Should returns generic rows.
         Override this method in inherited class"""
        pass

    def do_csv_export(self, queryset):
        f = StringIO.StringIO()
        data = self.get_csv_data(queryset)
        csvutil.UnicodeWriter(f).writerows(data)
        response = HttpResponse(f.getvalue(), content_type="application/csv")
        response['Content-Disposition'] = 'attachment; filename={}'.format(
            self.FILE_NAME)
        return response

    def get_pages(self, paginator, page):
        pages = paginator.page_range[
            max(0, page - 4):min(paginator.num_pages, page + 3)
        ]
        if 1 not in pages:
            pages.insert(0, 1)
            pages.insert(1, '...')
        if paginator.num_pages not in pages:
            pages.append('...')
            pages.append(paginator.num_pages)
        return pages
